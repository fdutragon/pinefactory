//@version=6

strategy("TRUMPUSDT-1M-Reversion", shorttitle="TRUMP", overlay=true,
     initial_capital=3000, currency=currency.USDT, pyramiding=0,
     commission_type=strategy.commission.percent, commission_value=0.04,
     calc_on_every_tick=false, calc_on_order_fills=false)

//@strategy_alert_message {{strategy.order.alert_message}}

// ========================= INPUTS =========================
risk_percentage         = input.float(20,  "Allocation per Trade (% of equity)", minval=1, maxval=100, step=1)
take_profit_pct         = input.float(0.55, "Take Profit (%) - Increased to target the middle", minval=0.05, maxval=500, step=0.05)
stop_loss_pct           = input.float(0.9, "Stop Loss (%) - Wider for volatility",   minval=0.05, maxval=500, step=0.05)

// --- TRAILING STOP CONFIGURATION ---
use_trailing_stop       = input.bool(true, "Use Trailing Stop")
ts_percent              = input.float(0.4, "Trailing Stop - Distance (%)", minval=0.05, step=0.05)
ts_activation_pct       = input.float(0.2, "Trailing Stop - Activation Trigger (%)", minval=0.05, step=0.05)

cooldown_after_close    = input.int(2,    "Cooldown after close (bars)", minval=0, maxval=100)
compound_basis_opt      = input.string("Equity (incl. PnL aberto)", "Compounding Basis", 
     options=["Equity (incl. PnL aberto)","Saldo fechado (PnL fechado apenas)"])

// --- OPTIMIZED INDICATOR INPUTS ---
rsi_period              = input.int(14, "RSI Period", minval=2, maxval=50)
bb_period               = input.int(20, "Bollinger Bands Period", minval=2, maxval=50)
bb_std                  = input.float(2.0, "BB Std Dev (Reference)", minval=0.1, maxval=5.0)
bb_std_extreme          = input.float(2.5, "BB Extreme Std Dev (Entry Trigger)", minval=1.0, maxval=6.0)
rsi_oversold            = input.float(25.0, "RSI Oversold (More extreme)", minval=0, maxval=50)
rsi_overbought          = input.float(65.0, "RSI Overbought (More extreme)", minval=50, maxval=100)
sinalOposto             = input.bool(true, "Close on opposite signal entry")

lot_step                = input.float(0.0, "Min. lot size (0 = disabled)", step=0.00000001)
min_bars_between_trades = input.int(1, "Minimum bars between trades", minval=1)
leverage                = input.int(1, "Leverage (x) for notional", minval=1, maxval=200)

// --- SIMULATION CONTROL ---
enable_simulation_after_loss = input.bool(false, "Enable Simulation Mode after Loss")

min_trades_daily        = input.int(4, "Minimum trades/day for check", minval=1, maxval=100)
min_win_rate_daily      = input.float(80.0, "Minimum daily win rate (%)", minval=0, maxval=100, step=1)

// --- HOURLY RESET (USING UTC-3) ---
reset_hour              = input.int(21, "Reset Hour (0-23, UTC-3)", minval=0, maxval=23)
reset_minute            = input.int(0, "Reset Minute (0-59)", minval=0, maxval=59)

// --- MARGIN ---
amount_margin_pct = input.float(1.0, "Extra margin on closing amount (%)", minval=0.0, maxval=10.0, step=0.1)

signal_id               = input.string("aeab05ce-8eb8-4b", "Signal ID (Binance)")
uid_value               = input.string("70a83eab29b0a1f012f6314b1b4c78467f688ed000739acd6c052e9f770515d7", "UID (Binance)")

// ========================= PERSISTENT VARIABLES =========================
var int   last_trade_bar        = na
var int   last_close_bar        = na
var float previous_netprofit    = 0.0
var string last_reset_date      = na 

var float current_position_size = 0.0
var float current_entry_price   = 0.0

var int   trades_today          = 0
var int   wins_today            = 0
var float win_rate_today        = 0.0
var float pnl_today             = 0.0
var float last_trade_pnl        = 0.0
var bool  paused_today_winrate  = false

var bool  simulation_mode       = false
var float simulated_entry_price = na
var string simulated_side       = na

// counter based on global closed trades
var int   last_closed_trades    = 0

// ========================= DAILY RESET IN UTC-3 =========================
// time() is always UTC; to force timezone, we use time() with session and timezone.
time_utc3  = time(timeframe.period, "", "Etc/GMT+3")
current_date_only = str.format_time(time_utc3, "yyyy-MM-dd", "Etc/GMT+3")
current_h  = hour(time_utc3, "Etc/GMT+3")
current_m  = minute(time_utc3, "Etc/GMT+3")
current_time_minutes = current_h * 60 + current_m
reset_time_minutes   = reset_hour * 60 + reset_minute
is_time_to_reset     = current_time_minutes >= reset_time_minutes
should_reset         = is_time_to_reset and (na(last_reset_date) or current_date_only != last_reset_date)

if should_reset
    trades_today         := 0
    wins_today           := 0
    win_rate_today       := 0.0
    pnl_today            := 0.0
    paused_today_winrate := false
    simulation_mode      := false
    simulated_entry_price := na
    simulated_side       := na
    last_reset_date      := current_date_only
    last_closed_trades   := strategy.closedtrades
    if barstate.isrealtime
        h_str = str.tostring(reset_hour, "00")
        m_str = str.tostring(reset_minute, "00")
        log.info("ðŸ”„ DAILY RESET (" + h_str + ":" + m_str + " UTC-3) - Date: " + current_date_only)

// ========================= INDICATORS =========================
rsi_current = ta.rsi(close, rsi_period)

// Standard Band (Visual)
[bb_upper, bb_middle, bb_lower] = ta.bb(close, bb_period, bb_std)

// Extreme Band (Trigger)
[bb_upper_ex, bb_middle_ex, bb_lower_ex] = ta.bb(close, bb_period, bb_std_extreme)

// Plotting Extra Bands
plot(bb_upper_ex, "BB Upper Extreme", color=color.new(color.red, 50))
plot(bb_lower_ex, "BB Lower Extreme", color=color.new(color.green, 50))

// ========================= OPTIMIZED ENTRY SIGNAL =========================
check_entry_signal() =>
    price_below_extreme = low <= bb_lower_ex
    price_above_extreme = high >= bb_upper_ex
    
    rsi_buy_cond  = rsi_current < rsi_oversold
    rsi_sell_cond = rsi_current > rsi_overbought
    
    buy_signal  = price_below_extreme and rsi_buy_cond
    sell_signal = price_above_extreme and rsi_sell_cond
    
    buy_signal ? 1 : sell_signal ? -1 : 0

signal = check_entry_signal()

// ========================= POSITION FLAGS =========================
flat           = strategy.position_size == 0
long_position  = strategy.position_size > 0
short_position = strategy.position_size < 0

// ========================= BANK & SIZING CALCULATIONS =========================
bank_value = compound_basis_opt == "Equity (incl. PnL aberto)" ? 
     strategy.equity : 
     math.max(0.0, strategy.initial_capital + strategy.netprofit)

calc_qty_from_base(percent, base) =>
    alloc_value = base * (percent / 100.0)
    math.max(0.0, alloc_value / close)

round_qty(qty, step) =>
    step > 0.0 ? math.max(step, math.floor(qty / step) * step) : qty

percent_to_ticks(price, pct) =>
    off_price = price * (pct / 100.0)
    int(math.max(1, math.round(off_price / syminfo.mintick)))

alloc_margin_value = bank_value * (risk_percentage / 100.0)
notional_value     = alloc_margin_value * leverage
notional_int       = int(math.round(notional_value))

// ========================= BINANCE PAYLOADS =========================
build_msg_entry(side, amount) =>
    symbol     = syminfo.ticker
    amount_str = str.tostring(math.round(amount, 2))
    '{"symbol":"' + symbol + '","side":"' + side + '","positionSide":"BOTH","investmentType":"notional_value","amount":"' + amount_str + '","price":"market","reduceOnly":false,"positionMode":"one_way_mode","signalId":"' + signal_id + '","uid":"' + uid_value + '"}'

build_msg_close_dynamic(side, pos_size) =>
    symbol     = syminfo.ticker
    notional   = pos_size * close
    notional_ex = notional * (1 + amount_margin_pct / 100.0)
    amount_str = str.tostring(math.round(notional_ex, 2))
    '{"symbol":"' + symbol + '","side":"' + side + '","positionSide":"BOTH","investmentType":"notional_value","amount":"' + amount_str + '","price":"market","reduceOnly":true,"positionMode":"one_way_mode","signalId":"' + signal_id + '","uid":"' + uid_value + '"}'

// ========================= CLOSURE DETECTION (ROBUST) =========================
// Uses strategy.closedtrades instead of position_size[1].
new_closed_trades = strategy.closedtrades - last_closed_trades
position_just_closed = new_closed_trades > 0

if position_just_closed
    last_close_bar          := bar_index
    current_position_size   := 0.0 

    // Total accumulated PnL since last trade is already in strategy.netprofit.
    last_trade_pnl          := strategy.netprofit - previous_netprofit
    previous_netprofit      := strategy.netprofit
    pnl_today               += last_trade_pnl
    trades_today            += new_closed_trades
    
    if last_trade_pnl > 0
        wins_today += 1
    
    win_rate_today := trades_today > 0 ? (wins_today / trades_today) * 100 : 0.0
    
    if barstate.isrealtime
        result_emoji = last_trade_pnl > 0 ? "âœ…" : "âŒ"
        log.info(result_emoji + " TRADE CLOSED | PnL: $" + str.tostring(math.round(last_trade_pnl, 2)) + 
                 " | Trades today: " + str.tostring(trades_today) + 
                 " | Win Rate: " + str.tostring(math.round(win_rate_today, 1)) + "%")
    
    if trades_today >= min_trades_daily and win_rate_today < min_win_rate_daily
        paused_today_winrate := true
        if barstate.isrealtime
            log.warning("â¸ PAUSE ACTIVATED - Win Rate below " + str.tostring(min_win_rate_daily) + "%")
    
    if last_trade_pnl < 0 and not simulation_mode and enable_simulation_after_loss
        simulation_mode       := true
        simulated_entry_price := na
        simulated_side        := na
        if barstate.isrealtime
            log.warning("ðŸ“Š SIMULATION MODE ACTIVATED - Waiting for positive signal")
    else if last_trade_pnl > 0 and simulation_mode
        simulation_mode       := false
        simulated_entry_price := na
        simulated_side        := na
        if barstate.isrealtime
            log.info("âœ… SIMULATION MODE DEACTIVATED - Resuming real operations")
    
    last_closed_trades := strategy.closedtrades

// ========================= SIMULATION LOGIC =========================
simulated_result = 0 

if simulation_mode and signal != 0
    would_be_long = signal == 1
    tp_level      = close + (close * take_profit_pct / 100)
    sl_level      = close - (close * stop_loss_pct / 100)
    
    if would_be_long
        simulated_result := close[1] >= tp_level ? 1 : close[1] <= sl_level ? -1 : 0
    else
        simulated_result := close[1] <= tp_level ? 1 : close[1] >= sl_level ? -1 : 0
    
    if simulated_result != 0 and barstate.isrealtime
        sim_emoji = simulated_result > 0 ? "âœ…" : "âŒ"
        log.info("ðŸ“Š SIMULATION " + sim_emoji + " | Signal " + (would_be_long ? "LONG" : "SHORT") + 
                 " would have resulted " + (simulated_result > 0 ? "POSITIVE" : "NEGATIVE"))
    
    if simulated_result > 0
        simulation_mode := false

// ========================= CLOSE ON OPPOSITE SIGNAL =========================
if (sinalOposto)
    if long_position and signal == -1 and barstate.isconfirmed
        close_payload = build_msg_close_dynamic("SELL", current_position_size)
        if barstate.isrealtime
            log.info("ðŸ”„ CLOSE BY OPPOSITE SIGNAL - LONG â†’ SELL signal")
        strategy.close("BUY", alert_message=close_payload)
        current_position_size := 0.0

    if short_position and signal == 1 and barstate.isconfirmed
        close_payload = build_msg_close_dynamic("BUY", current_position_size)
        if barstate.isrealtime
            log.info("ðŸ”„ CLOSE BY OPPOSITE SIGNAL - SHORT â†’ BUY signal")
        strategy.close("SELL", alert_message=close_payload)
        current_position_size := 0.0

// ========================= PAUSE AND COOLDOWN LOGIC =========================
cooldown_active      = not na(last_close_bar) and (bar_index - last_close_bar <= cooldown_after_close)
can_trade_timegap    = na(last_trade_bar) or (bar_index - last_trade_bar >= min_bars_between_trades)
paused_by_simulation = simulation_mode

if simulation_mode and simulated_result < 0
    paused_by_simulation := true

can_trade_now = not paused_today_winrate and not cooldown_active and can_trade_timegap and not paused_by_simulation

stayed_flat = flat and strategy.position_size[1] == 0
can_long    = (signal == 1) and stayed_flat and barstate.isconfirmed and can_trade_now
can_short   = (signal == -1) and stayed_flat and barstate.isconfirmed and can_trade_now

// ========================= LONG ENTRIES =========================
if can_long
    qty_calc            = round_qty(calc_qty_from_base(risk_percentage, bank_value), lot_step)
    entry_price         = close
    current_position_size := qty_calc
    current_entry_price := entry_price
    
    entry_payload = build_msg_entry("BUY", notional_int)

    if barstate.isrealtime
        log.info("ðŸŸ¢ LONG ENTRY | Extreme Reversion | Price: " + str.tostring(entry_price))
        log.info("ðŸ“¤ PAYLOAD ENTRY: " + entry_payload)

    strategy.entry("BUY", strategy.long, qty=qty_calc, alert_message=entry_payload)
    last_trade_bar := bar_index

    close_msg = build_msg_close_dynamic("SELL", qty_calc)
    
    exit_profit     = percent_to_ticks(entry_price, take_profit_pct)
    exit_loss       = percent_to_ticks(entry_price, stop_loss_pct)
    exit_trail_dist = use_trailing_stop ? percent_to_ticks(entry_price, ts_percent) : na
    exit_trail_act  = use_trailing_stop ? percent_to_ticks(entry_price, ts_activation_pct) : na
    
    strategy.exit("BUY EXIT", "BUY", profit=exit_profit, loss=exit_loss, trail_points=exit_trail_dist, trail_offset=exit_trail_act, alert_message=close_msg)

// ========================= SHORT ENTRIES =========================
if can_short
    qty_calc            = round_qty(calc_qty_from_base(risk_percentage, bank_value), lot_step)
    entry_price         = close
    current_position_size := qty_calc
    current_entry_price := entry_price
    
    entry_payload = build_msg_entry("SELL", notional_int)

    if barstate.isrealtime
        log.info("ðŸ”´ SHORT ENTRY | Extreme Reversion | Price: " + str.tostring(entry_price))
        log.info("ðŸ“¤ PAYLOAD ENTRY: " + entry_payload)

    strategy.entry("SELL", strategy.short, qty=qty_calc, alert_message=entry_payload)
    last_trade_bar := bar_index

    close_msg = build_msg_close_dynamic("BUY", qty_calc)
    
    exit_profit     = percent_to_ticks(entry_price, take_profit_pct)
    exit_loss       = percent_to_ticks(entry_price, stop_loss_pct)
    exit_trail_dist = use_trailing_stop ? percent_to_ticks(entry_price, ts_percent) : na
    exit_trail_act  = use_trailing_stop ? percent_to_ticks(entry_price, ts_activation_pct) : na

    strategy.exit("SELL EXIT", "SELL", profit=exit_profit, loss=exit_loss, trail_points=exit_trail_dist, trail_offset=exit_trail_act, alert_message=close_msg)

// ========================= STATUS LOG =========================
if barstate.isrealtime and barstate.islast
    reset_display = str.tostring(reset_hour, "00") + ":" + str.tostring(reset_minute, "00") + " UTC-3"
    status_msg = "ðŸ“Š STATUS | Position: " + (flat ? "FLAT" : long_position ? "LONG" : "SHORT") + 
                 " | Mode: " + (simulation_mode ? "SIMULATION" : "REAL") + 
                 " | WR Pause: " + (paused_today_winrate ? "YES" : "NO") + 
                 " | Reset: " + reset_display
    log.info(status_msg)

// ========================= VISUALIZATION =========================
plot(bb_upper,  title="BB Upper",  color=color.new(color.blue, 0))
plot(bb_middle, title="BB Middle", color=color.new(color.orange, 0))
plot(bb_lower,  title="BB Lower",  color=color.new(color.blue, 0))

// ========================= STATUS TABLE =========================
var table status_table = table.new(position=position.top_right, columns=3, rows=6, bgcolor=color.white, frame_width=2, frame_color=color.gray, border_width=1, border_color=color.gray)

table.cell(status_table, 0, 0, text="METRIC", text_size=size.small, text_color=color.black, bgcolor=color.new(color.gray, 70))
table.cell(status_table, 1, 0, text="VALUE",   text_size=size.small, text_color=color.black, bgcolor=color.new(color.gray, 70))

table.cell(status_table, 0, 1, text="Trades Today", text_size=size.small, text_color=color.black, bgcolor=color.white)
table.cell(status_table, 1, 1, text=str.tostring(trades_today), text_size=size.small, text_color=color.black, bgcolor=color.white)

table.cell(status_table, 0, 2, text="Win Rate", text_size=size.small, text_color=color.black, bgcolor=color.white)
table.cell(status_table, 1, 2, text=str.tostring(math.round(win_rate_today, 1)) + "%", text_size=size.small, text_color=color.black, bgcolor=color.white)

table.cell(status_table, 0, 3, text="PnL Day", text_size=size.small, text_color=color.black, bgcolor=color.white)
table.cell(status_table, 1, 3, text=str.tostring(math.round(pnl_today, 2)), text_size=size.small, text_color=color.black, bgcolor=color.white)

table.cell(status_table, 0, 4, text="Status", text_size=size.small, text_color=color.black, bgcolor=color.white)
status_text  = paused_today_winrate ? "â¸ PAUSE WIN" : simulation_mode ? "ðŸ“Š SIMULATION" : "â–¶ OPERATING"
status_color = paused_today_winrate ? color.new(color.red, 60) : simulation_mode ? color.new(color.orange, 60) : color.new(color.green, 60)
table.cell(status_table, 1, 4, text=status_text, text_size=size.small, text_color=color.black, bgcolor=status_color)

